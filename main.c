#include "mcc_generated_files/system/system.h"
#include <string.h>

//Use MPLAB MCC to make a project
//Add MSSP / I2C Host periferal using interrupts
//Set Chip frequency to ~16MHz and ensure the I2C speed in the MCC window is ~2-400 kHz.

int main(void)
{
    SYSTEM_Initialize();
    // If using interrupts in PIC18 High/Low Priority Mode you need to enable the Global High and Low Interrupts 
    // If using interrupts in PIC Mid-Range Compatibility Mode you need to enable the Global and Peripheral Interrupts 
    // Use the following macros to: 

    // Enable the Global Interrupts 
    INTERRUPT_GlobalInterruptEnable(); 

    // Disable the Global Interrupts 
    //INTERRUPT_GlobalInterruptDisable(); 

    // Enable the Peripheral Interrupts 
    INTERRUPT_PeripheralInterruptEnable(); 

    // Disable the Peripheral Interrupts 
    //INTERRUPT_PeripheralInterruptDisable();     

    /*This project is to get the LCD Display DFR0544 aka 1602 working 
     *on i2c from PIC16F1459 using interrupt code automatically generated by MCC
     *I had to use the scope intensively to figure out what the i2c addresses were
     *and what commends needed to be sent 
     * Note global and PIE interrupts need to be enabled
     * FOSC vs. i2c baud was also a problem, comms with the AIP31068
     * 
    */
    
    //LED on prompts single capture on scope
    do { LATBbits.LATB5 = 0; } while(0);
    __delay_ms(3000);
    
    //Comms with LCD Backlight PCA9633 to respond to sub-address 1 (0x61) but
    //because you are not supposed to use the all call address 0x60 for normal ops
    //but could not figure out how...
    //Still need these rows though or the backlight will not come on:
    uint8_t data4[2] = {0x00,0x0F};
    I2C1_Write(0x60, data4, 2);
    __delay_ms(10);  //required delay before close

    //0x08 = LED output state, 0x10 = full red
    //0x00 = off 0b00000001 = blue, 0b00000100 = green, 0b00010000 = red, 0b01000000 = off
    uint8_t data5[2] = {0x08,0x10};
    I2C1_Write(0x60, data5, 2);
    __delay_ms(10);  //required delay before close
    
    //Comms with the AIP31068 is needed for writing characters
    //Address quoted in some documentation is 7C but that doesn't work with MCC generated code
    //You have to use the scope set on ~500us to capture a single pulse to see the i2c command
    //and then decode it in the scope to figure out the issue if there is any address issue

    //Display on, cursor on, blink
    uint8_t data2[2] = {0x00,0x0F};
    I2C1_Write(0x3E, data2, 2);
    __delay_ms(10);

    //Clear display
    uint8_t data9[2] = {0x00,0x01};
    I2C1_Write(0x3E, data9, 2);
    __delay_ms(10);  //required delay before close

    //Write E to first char position
    uint8_t data7[2] = {0x40,0x45};
    I2C1_Write(0x3E, data7, 2);
    __delay_ms(10);  //required delay before close*/ 

    //Change DDRAM address to 15, last character in row
    uint8_t data11[2] = {0x00,0x8F};
    I2C1_Write(0x3E, data11, 2);
    __delay_ms(10);  //required delay before close

    //Write E to char position
    uint8_t data8[2] = {0x40,0x45};
    I2C1_Write(0x3E, data8, 2);
    __delay_ms(10);  //required delay before close*/ 

    //Change to 2 line display
    uint8_t data20[2] = {0x00,0x2C};
    I2C1_Write(0x3E, data20, 2);
    __delay_ms(10);

    //Clear display
    uint8_t data21[2] = {0x00,0x01};
    I2C1_Write(0x3E, data21, 2);
    __delay_ms(10);  //required delay before close

    //Write E to first char position
    uint8_t data22[2] = {0x40,0x45};
    I2C1_Write(0x3E, data22, 2);
    __delay_ms(10);  //required delay before close*/ 

    do { LATBbits.LATB5 = 1; } while(0);
    __delay_ms(2000);
    
    //Change DDRAM address to first character in 2nd row
    //we have a 16char display, but we have to go to the end of the 91063's range +1 = C0
    uint8_t data23[2] = {0x00,0xC0};
    I2C1_Write(0x3E, data23, 2);
    __delay_ms(10);  //required delay before close

    //Write string
    //0xC0 = send CGROM to DGRAM + another control byte to follow
    //0x40 = last control byte
    //uint8_t str[] = {0xC0,0x47,0xC0,0x48,0x40,0x49};
    //I2C1_Write(0x3E, str, 6);    
    //Create multi-character string like example above for a string variable
    const char* dispstr = "1234567";
    char str_with_ctrl_bytes[32] = {0};
    
    for (int x=0;x<strlen(dispstr)*2;x+=2){
        if (x == strlen(dispstr)*2-2){
            str_with_ctrl_bytes[x] = 0x40; //last byte
        }
        else{
            str_with_ctrl_bytes[x] = 0xC0; //continuation byte
        }
        str_with_ctrl_bytes[x+1] = dispstr[x/2];
    }
    I2C1_Write(0x3E, str_with_ctrl_bytes, strlen(dispstr)*2);
    
    while(1)
    {
    }    

}
